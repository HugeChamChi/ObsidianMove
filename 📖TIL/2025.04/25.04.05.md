## 몬테카를로 방 생성 알고리즘 

무작위 샘플링을 통해 던전 구조를 생성하는 시스템을 한번 만들어 봤다.
```cs
class Program  
{  
    static void Main()  
    {        DungeonGenerator generator = new DungeonGenerator();  
        Dungeon bestDungeon = generator.GenerateBestDungeon();  
        bestDungeon.Visualize();  
    }
}  
  
public class DungeonGenerator  
{  
    const int MAX_ROOMS = 15;  
    const int SIMULATION_COUNT = 500;  
    readonly Random random = new Random();  
  
    public Dungeon GenerateBestDungeon()  
    {     
       Dungeon bestDungeon = null;  
        double bestScore = double.MinValue;  
  
        for (int i = 0; i < SIMULATION_COUNT; i++)  
        {   
            Dungeon dungeon = GenerateDungeonAttempt();  
            double score = CalculateDungeonScore(dungeon);  
  
            if (score > bestScore)  
            {
              bestScore = score; 
              bestDungeon = dungeon; 
           }       
       }  
        return bestDungeon;  
    }  
    private Dungeon GenerateDungeonAttempt()  
    {        List<Room> rooms = new List<Room>();  
        int attemptCount = 0;  
  
        while (rooms.Count < MAX_ROOMS && attemptCount < MAX_ROOMS * 2)  
        {            Room newRoom = GenerateRandomRoom();  
            if (!CheckCollision(newRoom, rooms))  
            {                ConnectToNearest(newRoom, rooms);  
                rooms.Add(newRoom);  
            }            attemptCount++;       
        }  
        return new Dungeon(rooms);  
    }  
    private Room GenerateRandomRoom()  
    {        return new Room(  
            x: random.Next(0, 40),  
            y: random.Next(0, 20),  
            width: random.Next(3, 7),  
            height: random.Next(3, 5)  
        );   
    }  
    private bool CheckCollision(Room newRoom, List<Room> existingRooms)  
    {        return existingRooms.Any(room =>   
            newRoom.X < room.X + room.Width &&  
            newRoom.X + newRoom.Width > room.X &&  
            newRoom.Y < room.Y + room.Height &&  
            newRoom.Y + newRoom.Height > room.Y);  
    }  
    private void ConnectToNearest(Room newRoom, List<Room> rooms)  
    {        if (rooms.Count == 0) return;  
  
        Room nearest = rooms.OrderBy(r =>   
            Math.Pow(r.X - newRoom.X, 2) +   
Math.Pow(r.Y - newRoom.Y, 2)).First();  
  
        newRoom.ConnectedRooms.Add(nearest);  
        nearest.ConnectedRooms.Add(newRoom);  
    }  
    private double CalculateDungeonScore(Dungeon dungeon)  
    {        if (dungeon.Rooms.Count < 5) return -1000;  
  
        double connectivityScore = CalculateConnectivity(dungeon);  
        double roomScore = dungeon.Rooms.Count * 10;  
        double densityScore = CalculateDensity(dungeon);  
  
        return roomScore + connectivityScore * 30 + densityScore * 5;  
    }  
    private double CalculateConnectivity(Dungeon dungeon)  
    {        HashSet<Room> visited = new HashSet<Room>();  
        Queue<Room> queue = new Queue<Room>();  
        if (dungeon.Rooms.Count == 0) return 0;  
                queue.Enqueue(dungeon.Rooms[0]);  
        visited.Add(dungeon.Rooms[0]);  
  
        while (queue.Count > 0)  
        {            Room current = queue.Dequeue();  
            foreach (Room neighbor in current.ConnectedRooms)  
            {                if (!visited.Contains(neighbor))  
                {                    visited.Add(neighbor);  
                    queue.Enqueue(neighbor);  
                }           
             }       
        }  
        return (double)visited.Count / dungeon.Rooms.Count;  
    }  
    private double CalculateDensity(Dungeon dungeon)  
    {        int totalArea = dungeon.Rooms.Sum(r => r.Width * r.Height);  
        int minX = dungeon.Rooms.Min(r => r.X);  
        int maxX = dungeon.Rooms.Max(r => r.X + r.Width);  
        int minY = dungeon.Rooms.Min(r => r.Y);  
        int maxY = dungeon.Rooms.Max(r => r.Y + r.Height);  
  
        int dungeonArea = (maxX - minX) * (maxY - minY);  
        return dungeonArea > 0 ? (double)totalArea / dungeonArea : 0;  
    }
}  
  
public class Room  
{  
    public int X;  
    public int Y;  
    public int Width;  
    public int Height;  
    public List<Room> ConnectedRooms { get; } = new List<Room>();  
  
    public Room(int x, int y, int width, int height)  
    {        X = x;  
        Y = y;  
        Width = width;  
        Height = height;  
    }
}  
  
public class Dungeon  
{  
    public List<Room> Rooms { get; }  
  
    public Dungeon(List<Room> rooms)  
    {        Rooms = rooms;      }

    public void Visualize()  
    {    
        const int WIDTH = 60;  
        const int HEIGHT = 30;  
        char[,] grid = new char[WIDTH, HEIGHT];  
  
        for (int y = 0; y < HEIGHT; y++)  
            for (int x = 0; x < WIDTH; x++)  
                grid[x, y] = ' ';  
  
       foreach (Room room in Rooms)  
        {            for (int dx = 0; dx < room.Width; dx++)  
            {                for (int dy = 0; dy < room.Height; dy++)  
                {                    int px = room.X + dx;  
                    int py = room.Y + dy;  
                    if (px >= 0 && px < WIDTH && py >= 0 && py < HEIGHT)  
                    { grid[px, py] = dx == 0 || dx == room.Width - 1 ||   
dy == 0 || dy == room.Height - 1 ? '#' : '.';  
                    }           
                }          
           }        
        }  
        foreach (Room room in Rooms)  
        {            foreach (Room connected in room.ConnectedRooms)  
            {                DrawCorridor(grid, room, connected);  
            }        }  
        for (int y = 0; y < HEIGHT; y++)  
	        {            
		        for (int x = 0; x < WIDTH; x++)  
	            {          
	                  Console.Write(grid[x, y]);  
	            }        
	            Console.WriteLine();  
	        }   
	    }  
    private void DrawCorridor(char[,] grid, Room a, Room b)  
    {        int ax = a.X + a.Width / 2;  
        int ay = a.Y + a.Height / 2;  
        int bx = b.X + b.Width / 2;  
        int by = b.Y + b.Height / 2;  
  
       while (ax != bx)  
        {            if (ax < bx) ax++;  
            else ax--;  
            if (grid[ax, ay] == ' ') grid[ax, ay] = '.';  
        }  
       while (ay != by)  
        {            if (ay < by) ay++;  
            else ay--;  
            if (grid[ax, ay] == ' ') grid[ax, ay] = '.';  
        }  
     }
 }
```


<br>

몬테카를로 방식을 이용하여 500번 시뮬레이션 실행후 최고 ucb 점수의 던전을 택하였음

<br>

방 생성 규칙은

- 최대 15개 방 생성 시도
- 방 크기는 가로 3~6 / 세로 3~4
- 무작위 위치에 방 배치를 요구로 하였다.

방 연결 시스템은 BFS를 이용한 연결성 검증을 하였다.

`#` 은 벽 
`.` 은 바닥 및 복도
` ` 는 빈공간이라 하겠다.




<br>
<br>

