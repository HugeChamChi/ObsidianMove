## <font color="#ffdab9">알고리즘</font>

<br>

- 문제를 해결하기 위해 정해진 진행절차나 방법
- 컴퓨터에서 알고리즘은 어떤 행동을 하기위해 만들어진 프로그램명령어의 집합.

<br>

#### <font color="#b2f7ef">알고리즘의 조건</font>
1. 입력 : 알고리즘은 0개 이상의 입력을 가져야함
2. 출력 : 알고리즘은 최소 1개 이상의 결과를 가져야함
3. 명확성 : 수행 과정은 모호하지 않고 정확한 수단을 제공해야 함
4. 유한성 : 수행 과정은 무한하지않고 유한한 작업 이후에 정지 해야함
5. 효과성 : 모든 과정은 명백하게 실행 가능 해야 함.

### <font color="#b2f7ef"><font color="#77dd77">Big O 표기법이란 ?</font> </font>

<br>


Big O 표기법은 알고리즘의 **시간 복잡도**와 **공간 복잡도**를 나타내는 데 사용되는 수학적 표기법이다.
특히, 입력 크기 n 이 커질 때 알고리즘의 실행 시간이 어떻게 증가하는지를 표현함.

<br>
#### <font color="#b2f7ef">Big-O 표기법의 특징</font>

<br>

- 최악의 경우를 기준으로 측정함.
  - 이는 `최대 이 정도 시간 안에 끝낸다` 는 보장을 한다.
- 상수와 낮은 차수는 무시한다.
  - Big-O 표기법은 입력 크기가 매우 클 때의 성능을 나타내므로, 상수나 낮은 차수는 무시한다.
- 시간 복잡도와 공간 복잡도
  - 시간 복잡도 : 알고리즘이 실행되는 데 걸리는 시간.
  - 공간 복잡도 : 알고리즘이 사용하는 메모리 공간.

<br>


#### <font color="#b2f7ef">대표적인 시간 복잡도</font>


| Big-O 표기         | 설명                | 예시 알고리즘             |
| ---------------- | ----------------- | ------------------- |
| $$O(1)$$         | 상수 시간 : 입력 크기에 무관 | 배열에서 특정 인덱스 접근      |
| $$O(log\ n)$$    | 로그 시간: 로그에 비례     | 이진 탐색               |
| $$O(n)$$         | 선형 시간 : 입력 크기에 비례 | 배열 순회               |
| $$O(n\ log\ n)$$ | 선형 로그 시간          | 병합 정렬 , 퀵 정렬        |
| $$O(n^2)$$       | 이차 시간 : 제곱에 비례한다. | 이중 반복문 (버블 정렬 등)    |
| $$O(2^n)$$       | 지수 시간             | 완전 탐색 ( 재귀적 피보나치 등) |

## <font color="#77dd77"><font color="#ffdab9">정렬 알고리즘 </font></font>

이제 알고리즘의 개념 및 측정 방법에 대해서 배웠으니 본격적인 알고리즘을 배울 차례이다.
정렬 알고리즘이란 데이터를 특정한 기준에 따라 순서대로 배열하는 알고리즘이다.

<br>


<span style="font-size:30px"><strong><font color="#a473f8">정렬 알고리즘의 목적</font></strong></span>  


<br>

- 데이터 탐색 속도 향상 : 정렬된 데이터는 이진 탐색과 같은 효율적인 탐색 알고맂므을 사용할 수 있게 한다.
- 데이터 체계화 : 데이터를 보기 쉽고 논리적으로 정리한다.
- 다른 알고리즘의 전처리 : 일부 알고리즘은 입력 데이터가 정렬 되어있을때 더 효율적으로 작동한다.


<br>

여기에서 나는 정렬 알고리즘중 비교 기반 정렬 알고리즘부터 뜯어볼 생각이다.

<Br>

### <font color="#77dd77">BubbleSort ( 버블 정렬 )</font>

<br>


![[Desktop 2025.04.03 - 05.23.20.02 (1).gif]]

버블 정렬(Bubble Sort)은 가장 간단한 정렬 알고리즘 중 하나로, **인접한 두 요소를 비교하여 순서가 잘못된 경우 교환**하는 방식으로 동작한다.
이름처럼 배열의 큰 값이 `거품처럼` 점점 위로 올라가는 것과 비슷한 방식으로 작동한다.

<br>

#### <font color="#b2f7ef">버블 정렬의 작동 원리</font>

<br>


1. 배열 첫 번째 요소부터 시작하여 인접한 두 요소를 비교한다.
2. 만약 `앞의 값`이 `뒤의 값`보다 크다면 두 값을 교한한다.
3. 한 번의 반복이 끝나면 가장 큰 값이 배열의 맨 뒤로 이동한다.
4. 이 과정을 배열 길이 만큼 반복하여 모든 요소를 정렬한다.

<br>


```cs
public static void BubbleSort(int[] array)
{
    int n = array.Length; // 배열의 길이
    for (int i = 0; i < n - 1; i++) // 외부 루프: 전체 패스 반복
    {
        for (int j = 0; j < n - i - 1; j++) // 내부 루프: 비교 범위 점차 줄어듬
        {
            if (array[j] > array[j + 1]) // 인접한 두 요소 비교
            {
                // 두 값을 교환
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
```

<br>
#### <font color="#b2f7ef">버블 정렬의 장단점 : </font>

<br>


장점:

1. 구현이 매우 간단하고 직관적이다.
    
2. 안정적인 정렬(같은 값의 순서 유지).
    

단점:

1. 느린 알고리즘으로 대규모 데이터에는 적합하지 않다.
    
2. 다른 O(n2)O(n2) 알고리즘(삽입/선택 정렬)보다 비효율적이다.


---
1. int n = array.Length
   1-1. 배열의 길이를 변수 n 에 저장하여 배열의 길이를 매번 계산할 필요 없게만듬
   1-2. 
2. for (int i = 0 ; i < n - 1; i ++)
   2-1. 여기서 i 는 현재 몇번째로 돌았는지를 나타낸다.
   2-2  총 n-1 번 반복한다
   2-2(1) 예를 들어, 배열 길이가 5라면 i 는 0,1,2,3 까지 실행함
3. for (int j = 0 ; j < n - i - 1; j++)
   3-1. `j` 는 현재 비교중인 위치를 나타냄.
   3-2. `n - i - 1` 는 이미 정렬된 부분을 제외한 나머지 범위를 나타냄
4. 조건문 (`if (array[j]> array[j+1])`)
   4-1. 인접한 두 요소를 비교하여 앞의 값이 더 크다면 교환함.
5. Swap 
   ```cs
int temp = array[j];
array[j] = array[j+1];
array[j+1] = temp;
```
	5-1. 이 과정을 통해 두 값을 교환함.
	5-2. 이 과정에서 임시 변수(temp)를 이용해 값이 덮어 쓰이지 않도록함.


<br>
<br>


### <font color="#77dd77">SelectionSort ( 선택 정렬 )</font>

<br>

![[Desktop 2025.04.03 - 09.33.44.05.gif]]

<br>

선택 정렬(Selection Sort)은 **가장 간단한 정렬 알고리즘 중 하나**로, 배열에서 가장 작은 값을 선택하여 맨 앞부터 순서대로 정렬하는 방식으로 동작한다.
이름 그대로 "선택"이라는 개념에 기반하여 작동한다.

#### 선택 정렬의 작동 원리
1. 배열에서 가장 작은 값 찾기 :
   1-1. 배열의 첫 번째 요소부터 끝까지 탐색하여 가장 작은 값을 찾음
2. 가장 작은 값과 현재 위치 교환 : 
   2-2 찾은 값을 배열의 첫 번째 위치로 이동한다.
3. 다음 반복:
   3-1 두 번째 요소부터 끝까지 다시 탐색하여 가장 작은 값을 찾고 , 두 번째 위치로 이동한다.
4. 반복 종료:
   4-1 배열의 모든 요소가 정렬 될 때 까지 이 과정을 반복.

```cs
public static void SelectionSort(int[] array)
{
    int n = array.Length;
    for (int i = 0; i < n - 1; i++) // 외부 루프: 현재 위치 선택
    {
        int minIndex = i; // 현재 구간에서 가장 작은 값의 인덱스 저장
        for (int j = i + 1; j < n; j++) // 내부 루프: 나머지 구간 탐색
        {
            if (array[j] < array[minIndex]) // 더 작은 값을 발견하면
            {
                minIndex = j; // 최소값 인덱스 갱신
            }
        }
        // 현재 위치와 최소값 위치 교환
        int temp = array[i];
        array[i] = array[minIndex];
        array[minIndex] = temp;
    }
}
```

1. for (int i = 0 ; i < n - 1 ; i ++ )
   1-1. 정렬할 위치를 선택하는 루프이다.
   1-2. `i` 는 현재 정렬 중인 위치를 나타낸다.
   1-3. 총 `n-1` 번 반복되며 , 마지막 요소는 자동으로 정렬 되므로 더이상 비교할 필요가없음
2. for (int j = i + 1 ; j < n; j++)
   2-1. 현재 선택된 위치 이후의 값들 중에서 가장 작은 값을 찾음
   2-2. `j`는 탐색 범위를 나타낸다.
   2-3. `minIndex`를 갱신하여 가장 작은 값의 위치를 저장함.
3. Swap 로직 ( int temp = ...)
   3-1. 현재 위치(`i`) 와 가장 작은 값의 위치(minIndex)를 교환함
   3-2. 이를 통해 가장 작은 값이 정렬됨

<br>

#### <font color="#b2f7ef">선택정렬의 장단점</font>


장점

1. 구현이 간단하고 직관적입니다.
    
2. 추가 메모리가 필요하지 않습니다.
    
3. 데이터 크기가 작을 경우 효율적으로 동작합니다.
    

단점

1. 시간 복잡도가 $O(n^2)$ 로 비효율적임
    
2. 안정적인 정렬이 아님(같은 값의 순서가 바뀔 수 있음).


<br>
<br>


### <font color="#77dd77">MergeSort (병합정렬)</font>

<br>


**Merge Sort**는 **효율적인 분할 정복 기반의 정렬 알고리즘**으로, 배열을 작은 부분으로 나누고, 각각을 정렬한 후 합병하여 전체를 정렬하는 방식으로 작동합니다.

#### **MergeSort(병합정렬)의 작동 원리**

1. **분할(Divide)**:
    
    - 배열을 절반으로 나눕니다. 이 과정을 배열이 1개의 요소만 남을 때까지 반복합니다.
        
2. **정복(Conquer)**:
    
    - 나뉜 배열을 재귀적으로 정렬합니다.
        
3. **합병(Merge)**:
    
    - 정렬된 두 배열을 하나로 합칩니다.
        

#### **MergeSort 구현**

```cs
public static void MergeSort(int[] array)
{
    if (array.Length <= 1) return;

    int mid = array.Length / 2;
    int[] left = new int[mid];
    int[] right = new int[array.Length - mid];

    Array.Copy(array, 0, left, 0, mid);
    Array.Copy(array, mid, right, 0, array.Length - mid);

    MergeSort(left);
    MergeSort(right);

    Merge(array, left, right);
}

private static void Merge(int[] array, int[] left, int[] right)
{
    int i = 0, j = 0, k = 0;

    while (i < left.Length && j < right.Length)
    {
        if (left[i] <= right[j])
        {
            array[k++] = left[i++];
        }
        else
        {
            array[k++] = right[j++];
        }
    }

    while (i < left.Length)
    {
        array[k++] = left[i++];
    }

    while (j < right.Length)
    {
        array[k++] = right[j++];
    }
}

```

#### **<font color="#b2f7ef">코드 분석</font>**

1. **분할 단계**:
    
    - `Array.Copy`를 사용해 배열을 왼쪽과 오른쪽으로 나눕니다.
        
    - 재귀적으로 `MergeSort`를 호출해 더 작은 부분으로 나눕니다.
        
2. **합병 단계**:
    
    - 두 개의 정렬된 배열(왼쪽과 오른쪽)을 비교하며 하나의 정렬된 배열로 병합합니다.
        

#### **<font color="#b2f7ef">Merge Sort의 장단점</font>**

**장점**

1. **안정적인 정렬**: 동일한 값들의 상대적 순서가 유지됩니다.
    
2. **일관된 시간 복잡도**: 항상 $O(nlog⁡n)$ 의 시간 복잡도를 가집니다.
    
3. 큰 데이터 세트에 적합: 외부 메모리에서도 효율적으로 동작합니다.
    

**단점**

1. 추가 메모리 필요: 병합 과정에서 추가 공간 $(O(n)$ 이 필요로한다.
    
2. 작은 데이터 세트에서는 비효율적: 삽입 정렬 등 다른 알고리즘이 더 빠를 수 있다.