## <font color="#ffdab9">알고리즘</font>

<br>

- 문제를 해결하기 위해 정해진 진행절차나 방법
- 컴퓨터에서 알고리즘은 어떤 행동을 하기위해 만들어진 프로그램명령어의 집합.

#### 알고리즘의 조건
1. 입력 : 알고리즘은 0개 이상의 입력을 가져야함
2. 출력 : 알고리즘은 최소 1개 이상의 결과를 가져야함
3. 명확성 : 수행 과정은 모호하지 않고 정확한 수단을 제공해야 함
4. 유한성 : 수행 과정은 무한하지않고 유한한 작업 이후에 정지 해야함
5. 효과성 : 모든 과정은 명백하게 실행 가능 해야 함.

### <font color="#b2f7ef"><font color="#77dd77">Big O 표기법이란 ?</font> </font>

<br>


Big O 표기법은 알고리즘의 **시간 복잡도**와 **공간 복잡도**를 나타내는 데 사용되는 수학적 표기법이다.
특히, 입력 크기 n 이 커질 때 알고리즘의 실행 시간이 어떻게 증가하는지를 표현함.

<br>
#### <font color="#b2f7ef">Big-O 표기법의 특징</font>

<br>

- 최악의 경우를 기준으로 측정함.
  - 이는 `최대 이 정도 시간 안에 끝낸다` 는 보장을 한다.
- 상수와 낮은 차수는 무시한다.
  - Big-O 표기법은 입력 크기가 매우 클 때의 성능을 나타내므로, 상수나 낮은 차수는 무시한다.
- 시간 복잡도와 공간 복잡도
  - 시간 복잡도 : 알고리즘이 실행되는 데 걸리는 시간.
  - 공간 복잡도 : 알고리즘이 사용하는 메모리 공간.

<br>


#### <font color="#b2f7ef">대표적인 시간 복잡도</font>


| Big-O 표기         | 설명                | 예시 알고리즘             |
| ---------------- | ----------------- | ------------------- |
| $$O(1)$$         | 상수 시간 : 입력 크기에 무관 | 배열에서 특정 인덱스 접근      |
| $$O(log\ n)$$    | 로그 시간: 로그에 비례     | 이진 탐색               |
| $$O(n)$$         | 선형 시간 : 입력 크기에 비례 | 배열 순회               |
| $$O(n\ log\ n)$$ | 선형 로그 시간          | 병합 정렬 , 퀵 정렬        |
| $$O(n^2)$$       | 이차 시간 : 제곱에 비례한다. | 이중 반복문 (버블 정렬 등)    |
| $$O(2^n)$$       | 지수 시간             | 완전 탐색 ( 재귀적 피보나치 등) |

## <font color="#77dd77"><font color="#ffdab9">정렬 알고리즘 </font></font>

이제 알고리즘의 개념 및 측정 방법에 대해서 배웠으니 본격적인 알고리즘을 배울 차례이다.
정렬 알고리즘이란 데이터를 특정한 기준에 따라 순서대로 배열하는 알고리즘이다.

<br>


<span style="font-size:30px"><strong><font color="#a473f8">정렬 알고리즘의 목적</font></strong></span>  


<br>

- 데이터 탐색 속도 향상 : 정렬된 데이터는 이진 탐색과 같은 효율적인 탐색 알고맂므을 사용할 수 있게 한다.
- 데이터 체계화 : 데이터를 보기 쉽고 논리적으로 정리한다.
- 다른 알고리즘의 전처리 : 일부 알고리즘은 입력 데이터가 정렬 되어있을때 더 효율적으로 작동한다.


<br>

여기에서 나는 정렬 알고리즘중 비교 기반 정렬 알고리즘부터 뜯어볼 생각이다.

<Br>

#### <font color="#b2f7ef"><font color="#77dd77">BubbleSort ( 버블 정렬 )</font></font>

![[Desktop 2025.04.03 - 05.23.20.02 (1).gif]]

버블 정렬(Bubble Sort)은 가장 간단한 정렬 알고리즘 중 하나로, **인접한 두 요소를 비교하여 순서가 잘못된 경우 교환**하는 방식으로 동작한다.
이름처럼 배열의 큰 값이 `거품처럼` 점점 위로 올라가는 것과 비슷한 방식으로 작동한다.

<br>

#### 버블 정렬의 작동 원리
1. 배열 첫 번째 요소부터 시작하여 인접한 두 요소를 비교한다.
2. 만약 `앞의 값`이 `뒤의 값`보다 크다면 두 값을 교한한다.
3. 한 번의 반복이 끝나면 가장 큰 값이 배열의 맨 뒤로 이동한다.
4. 이 과정을 배열 길이 만큼 반복하여 모든 요소를 정렬한다.

```cs
public static void BubbleSort(int[] array)
{
    int n = array.Length; // 배열의 길이
    for (int i = 0; i < n - 1; i++) // 외부 루프: 전체 패스 반복
    {
        for (int j = 0; j < n - i - 1; j++) // 내부 루프: 비교 범위 점차 줄어듬
        {
            if (array[j] > array[j + 1]) // 인접한 두 요소 비교
            {
                // 두 값을 교환
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
```

<br>
장점:

1. 구현이 매우 간단하고 직관적이다.
    
2. 안정적인 정렬(같은 값의 순서 유지).
    

단점:

1. 느린 알고리즘으로 대규모 데이터에는 적합하지 않다.
    
2. 다른 O(n2)O(n2) 알고리즘(삽입/선택 정렬)보다 비효율적이다.


---
1. int n = array.Length
   1-1. 배열의 길이를 변수 n 에 저장하여 배열의 길이를 매번 계산할 필요 없게만듬
   1-2. 
2. for (int i = 0 ; i < n - 1; i ++)
   2-1. 여기서 i 는 현재 몇번째로 돌았는지를 나타낸다.
   2-2  총 n-1 번 반복한다
   2-2(1) 예를 들어, 배열 길이가 5라면 i 는 0,1,2,3 까지 실행함
3. for (int j = 0 ; j < n - i - 1; j++)
   3-1. `j` 는 현재 비교중인 위치를 나타냄.
   3-2. `n - i - 1` 는 이미 정렬된 부분을 제외한 나머지 범위를 나타냄
4. 조건문 (`if (array[j]> array[j+1])`)
   4-1. 인접한 두 요소를 비교하여 앞의 값이 더 크다면 교환함.
5. Swap 과정
   ```cs
int temp = array[j];
array[j] = array[j+1];
array[j+1] = temp;
```
	5-1. 이 과정을 통해 두 값을 교환함.
	5-2. 이 과정에서 임시 변수(temp)를 이용해 값이 덮어 쓰이지 않도록함.

















<br>




